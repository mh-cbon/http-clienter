// Package http-clienter generates http client of a type
package main

//go:generate lister utils/strings.go string:*StringSlice

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"

	"golang.org/x/tools/go/loader"

	"github.com/mh-cbon/astutil"
	"github.com/mh-cbon/http-clienter/utils"
	httper "github.com/mh-cbon/httper/lib"
)

var name = "http-clienter"
var version = "0.0.0"

func main() {

	var help bool
	var h bool
	var ver bool
	var v bool
	var outPkg string
	var mode string
	flag.BoolVar(&help, "help", false, "Show help.")
	flag.BoolVar(&h, "h", false, "Show help.")
	flag.BoolVar(&ver, "version", false, "Show version.")
	flag.BoolVar(&v, "v", false, "Show version.")
	// flag.StringVar(&outPkg, "p", "", "Package name of the new code.")
	flag.StringVar(&mode, "mode", "", "The genration mode.")

	flag.Parse()

	if ver || v {
		showVer()
		return
	}
	if help || h {
		showHelp()
		return
	}

	if flag.NArg() < 2 {
		panic("wrong usage")
	}
	args := flag.Args()

	pkgToLoad := getPkgToLoad()
	dest := os.Stdout

	o := args[0]
	restargs := args[1:]

	prog := astutil.GetProgram(pkgToLoad)
	pkg := prog.Package(pkgToLoad)

	foundMethods := astutil.FindMethods(pkg)

	if strings.Index(o, "/") > -1 {
		d := filepath.Dir(o)
		os.MkdirAll(d, os.ModePerm)
		outPkg = filepath.Base(d)
	} else if outPkg == "" {
		outPkg = os.Getenv("GOPACKAGE")
	}

	if o != "-" {
		f, err := os.Create(o)
		if err != nil {
			panic(err)
		}
		dest = f
		defer func() {
			f.Close()
			cmd := exec.Command("go", "fmt", args[0])
			cmd.Stdout = os.Stdout
			cmd.Stderr = os.Stderr
			cmd.Run()
		}()
	}

	fmt.Fprintf(dest, "package %v\n\n", outPkg)
	fmt.Fprintln(dest, `// file generated by`)
	fmt.Fprintf(dest, "// github.com/mh-cbon/%v\n", name)
	fmt.Fprintln(dest, `// do not edit`)
	fmt.Fprintln(dest, "")
	fmt.Fprintf(dest, "import (\n")
	fmt.Fprintf(dest, "	%q\n", "net/http")
	fmt.Fprintf(dest, "	%q\n", "net/url")
	fmt.Fprintf(dest, "	%q\n", "fmt")
	fmt.Fprintf(dest, "	%q\n", "io")
	fmt.Fprintf(dest, "	%q\n", "strings")
	fmt.Fprintf(dest, "	%q\n", "bytes")
	if mode == gorillaMode {
		fmt.Fprintf(dest, "	%q\n", "github.com/gorilla/mux")
	}
	fmt.Fprintf(dest, "	%q\n", "encoding/json")
	// fmt.Fprintf(dest, "	%q\n", "github.com/gorilla/mux")
	// fmt.Fprintf(dest, "	%v %q\n", "httper", "github.com/mh-cbon/httper/lib")
	fmt.Fprintf(dest, ")\n")
	fmt.Fprintf(dest, "\n\n")
	// cheat.
	fmt.Fprintf(dest, `var xxNetHTTP = http.StatusOK
	var xxNetURL = url.PathEscape
	var xxFmt = fmt.Println
	var xxIo = io.Copy
	var xxStrings = strings.Replace
	var xxBytes = bytes.Compare
	`)

	todos := checkArgs(restargs)
	for _, todo := range todos {
		res := processType(mode, todo[1], todo[0], prog, pkg, foundMethods)
		io.Copy(dest, &res)
	}
}

func checkArgs(args []string) [][]string {
	ret := [][]string{}
	for _, todo := range args {
		y := strings.Split(todo, ":")
		if len(y) != 2 {
			panic("wrong name " + todo)
		}
		ret = append(ret, y)
	}
	return ret
}

func showVer() {
	fmt.Printf("%v %v\n", name, version)
}

func showHelp() {
	showVer()
	fmt.Println()
	fmt.Println("Usage")
	fmt.Println()
	fmt.Printf("	%v [out] [...types]\n\n", name)
	fmt.Printf("	out:   Output destination of the results, use '-' for stdout.\n")
	fmt.Printf("	types: A list of types such as src:dst.\n")
	fmt.Printf("	mode:  The generation mode.\n")
	fmt.Println()
}

func processType(mode, destName, srcName string, prog *loader.Program, pkg *loader.PackageInfo, foundMethods map[string][]*ast.FuncDecl) bytes.Buffer {

	var b bytes.Buffer
	dest := &b

	dstConcrete := astutil.GetUnpointedType(destName)
	srcConcrete := astutil.GetUnpointedType(srcName)
	structType := astutil.FindStruct(pkg, srcConcrete)
	structComment := astutil.GetComment(prog, structType.Pos())
	// todo: might do better to send only annotations or do other improvemenets.
	structComment = makeCommentLines(structComment)
	structAnnotations := astutil.GetAnnotations(structComment, "@")

	// Declare the new type

	fmt.Fprintf(dest, `
// %v is an http-clienter of %v.
%v`, dstConcrete, srcName, structComment)

	if mode == gorillaMode {
		fmt.Fprintf(dest, `
	type %v struct{
		router *mux.Router
		embed *http.Client
	  Base string
	}
			`, dstConcrete)

	} else {
		fmt.Fprintf(dest, `
	type %v struct{
		embed *http.Client
	  Base string
	}
			`, dstConcrete)
	}

	// Make the constructor
	// should param *http.Client be an interface ?
	fmt.Fprintf(dest, `// New%v constructs an http-clienter of %v
`, dstConcrete, srcName)

	if mode == gorillaMode {
		fmt.Fprintf(dest, `func New%v(router *mux.Router, embed *http.Client) *%v {
	ret := &%v{
		router: router,
		embed: embed,
	}
  return ret
}
`, dstConcrete, dstConcrete, dstConcrete)
	} else {
		fmt.Fprintf(dest, `func New%v(embed *http.Client) *%v {
	ret := &%v{
		embed: embed,
	}
  return ret
}
`, dstConcrete, dstConcrete, dstConcrete)
	}

	for _, m := range foundMethods[srcConcrete] {
		methodName := astutil.MethodName(m)

		comment := astutil.GetComment(prog, m.Pos())
		annotations := astutil.GetAnnotations(comment, "@")
		annotations = mergeAnnotations(structAnnotations, annotations)
		params := astutil.MethodParams(m)
		paramNames := astutil.MethodParamNames(m)
		lParamNames := commaArgsToSlice(paramNames)

		if route, ok := annotations["route"]; ok {

			getParams := ""
			postParams := ""
			// postParams := "form := url.Values{}"
			routeName, _ := annotations["name"]

			managedParamNames := utils.NewStringSlice()
			routeParamsExpr := []string{}
			routeParamNames := getRouteParamsFromRoute(mode, route)
			for _, p := range routeParamNames {
				routeParamsExpr = append(routeParamsExpr, fmt.Sprintf("%q", p))
				routeParamsExpr = append(routeParamsExpr, p)
				methodParam := getMethodParamForRouteParam(mode, lParamNames, p, managedParamNames)
				if methodParam == "" {
					log.Println("route param not identified into the method parameters " + p)
					continue
				}
				managedParamNames.Push(methodParam)
			}

			for _, p := range lParamNames {
				if p == reqBodyVarName {
					continue
				}
				if !managedParamNames.Contains(p) {
					prefix := getVarPrefix(mode, p)
					rParamName := getVarValueName(mode, p)
					if prefix == "get" || prefix == "url" || prefix == "req" {
						getParams += fmt.Sprintf("url.Query().Add(%q, %v)", rParamName, p)
						managedParamNames.Push(p)

					} else if prefix == "post" {
						getParams += fmt.Sprintf("form.Add(%q, %v)", rParamName, p)
						managedParamNames.Push(p)
					}
				}
			}

			k := ""
			if len(routeParamsExpr) > 0 {
				k = strings.Join(routeParamsExpr, ", ")
				k = k[:len(k)-2]
			}
			url := ""
			if routeName != "" {
				url = fmt.Sprintf(`url, URLerr := t.router.Get(%q).URL(%v)
				`, routeName, k)
			} else {
				url += fmt.Sprintf(`surl := %q
					`, route)

				managedParamNames = utils.NewStringSlice()
				for _, p := range routeParamNames {
					methodParam := getMethodParamForRouteParam(mode, lParamNames, p, managedParamNames)
					if methodParam == "" {
						log.Println("route param not identified into the method parameters " + p)
						continue
					}
					url += fmt.Sprintf(`surl = strings.Replace(surl, "{%v}", fmt.Sprintf("%%v", %v), 1)
								`, p, methodParam)
					managedParamNames.Push(methodParam)
				}

				url += fmt.Sprintf(`url, URLerr := url.ParseRequestURI(surl)
				`)
			}
			url += handleErr("URLerr")

			if getParams != "" {
				url += fmt.Sprintf(`%v
					`, getParams)
			}
			if postParams != "" {
				url += fmt.Sprintf(`form := url.Values{}
					%v
					`, postParams)
			}

			url += fmt.Sprint(`finalURL := url.String()
				`)
			preferedMethod := getPreferredMethod(annotations)
			if base, ok := annotations["base"]; ok {
				url += fmt.Sprintf(`finalURL = fmt.Sprint(%q, %q, finalURL)
				`, "%v%v", base)
			}
			url += fmt.Sprintf(`finalURL = fmt.Sprintf(%q, t.Base, finalURL)
			`, "%v%v")

			body := ""
			if postParams != "" {
				body += fmt.Sprintf(`
					body = strings.NewReader(form.Encode())`)

			} else if hasReqBody(lParamNames) {
				// should test that
				amp := ""
				if !astutil.IsAPointedType(getReqBodyType(strings.Split(params, ", "))) {
					amp = "&"
				}
				body += fmt.Sprintf(`
						data, reqBodyErr := json.Marshal(%v%v)
						`, amp, "reqBody")
				body += handleErr("reqBodyErr")
				body += fmt.Sprintf(`
						body = bytes.NewBuffer(data)`)
			}

			body += fmt.Sprintf(`
				%v
					req, reqErr := http.NewRequest(%q, finalURL, body)
					`, url, preferedMethod)
			body += handleErr("reqErr")
			body += fmt.Sprintf(`ret = req
				`)

			fmt.Fprintf(dest, `// %v constructs a request to %v
      `, methodName, route)
			fmt.Fprintf(dest, `func(t %v) %v(%v) (*http.Response, error) {
        var ret *http.Request
        var body io.Reader
        // var err error
        %v
        return t.embed.Do(ret)
      }
      `, destName, methodName, params, body)

		}

	}

	return b
}

func getMethodParamForRouteParam(mode string,
	methodParamNames []string,
	routeParamName string,
	managed *utils.StringSlice) string {
	for _, methodParamName := range methodParamNames {
		prefix := getVarPrefix(mode, methodParamName)
		if prefix == "route" || prefix == "get" || prefix == "req" || prefix == "url" {
			valueName := getVarValueName(mode, methodParamName)
			if strings.ToLower(valueName) == strings.ToLower(routeParamName) {
				return methodParamName
			}
		}
	}
	return ""
}

func handleErr(errVarName string) string {
	return fmt.Sprintf(`if %v!= nil {
return nil, %v
}
`, errVarName, errVarName)
}

func hasReqBody(paramNames []string) bool {
	for _, p := range paramNames {
		if p == "reqBody" {
			return true
		}
	}
	return false
}

func getReqBodyType(params []string) string {
	for _, p := range params {
		k := strings.Split(p, " ")
		k[0] = strings.TrimSpace(k[0])
		if k[0] == "reqBody" && len(k) > 1 {
			return strings.TrimSpace(k[1])
		}
	}
	return ""
}

var re = regexp.MustCompile(`({[^}]+(:[^}]+|)})`)

func routeHasParam(mode, route, paramName string) bool {
	if mode == gorillaMode {
		for _, p := range getRouteParamNamesFromRoute(mode, route) {
			if p == paramName {
				return true
			}
		}
	}
	return false
}

func getRouteParamsFromRoute(mode, route string) []string {
	ret := []string{}
	if mode == gorillaMode {
		//todo: find a better way.
		res := re.FindAllStringSubmatch(route, -1)
		for _, r := range res {
			if len(r) > 0 {
				k := strings.TrimSpace(r[0])
				if len(k) > 2 { // there is braces inside
					k = k[1 : len(k)-1]
					ret = append(ret, k)
				}
			}
		}
	}
	return ret
}

func getRouteParamNamesFromRoute(mode, route string) []string {
	ret := []string{}
	if mode == gorillaMode {
		//todo: find a better way.
		res := re.FindAllStringSubmatch(route, -1)
		for _, r := range res {
			if len(r) > 0 {
				k := strings.TrimSpace(r[0])
				if len(k) > 2 { // there is braces inside
					k = k[1 : len(k)-1]
					if strings.Index(k, ":") > -1 {
						j := strings.Split(k, ":")
						ret = append(ret, j[0])
					} else {
						ret = append(ret, k)
					}
				}
			}
		}
	}
	return ret
}

var gorillaMode = "gorilla"
var stdMode = "std"
var reqBodyVarName = "reqBody"

func isUsingConvetionnedParams(mode, params string) bool {
	lParams := strings.Split(params, ",")
	for _, param := range lParams {
		k := strings.Split(param, " ")
		if len(k) > 1 {
			varType := strings.TrimSpace(k[1])
			if varType == "http.ResponseWriter" {
				return true

			} else if varType == "*http.Request" {
				return true

			} else if varType == "httper.Cookier" {
				return true

			} else if varType == "httper.Sessionner" {
				return true
			}
		}
		varName := strings.TrimSpace(k[0])
		if isConvetionnedParam(mode, varName) {
			return true
		}
	}
	return false
}

func isConvetionnedParam(mode, varName string) bool {
	if varName == reqBodyVarName {
		return true
	}
	return getVarPrefix(mode, varName) != ""
}

func getParamConvention(mode, varName string) string {
	if varName == reqBodyVarName {
		return reqBodyVarName
	}
	return getVarPrefix(mode, varName)
}

func getSessionProviderFactory(mode string) httper.SessionProvider {
	var factory httper.SessionProvider
	if mode == stdMode {
		factory = &httper.VoidSessionProvider{}
	} else if mode == gorillaMode {
		factory = &httper.GorillaSessionProvider{}
	}
	return factory
}

func getDataProviderFactory(mode string) httper.DataerProvider {
	var factory httper.DataerProvider
	if mode == stdMode {
		factory = &httper.StdHTTPDataProvider{}
	} else if mode == gorillaMode {
		factory = &httper.GorillaHTTPDataProvider{}
	}
	return factory
}

func getDataProvider(mode string) *httper.DataProviderFacade {
	return getDataProviderFactory(mode).MakeEmpty().(*httper.DataProviderFacade)
}

func getVarPrefix(mode, varName string) string {
	ret := ""
	provider := getDataProvider(mode)
	for _, p := range provider.Providers {
		prefix := p.GetName()
		if strings.HasPrefix(varName, strings.ToLower(prefix)) {
			f := string(varName[len(prefix):][0])
			if f == strings.ToUpper(f) {
				ret = prefix
				break
			}
		} else if strings.HasPrefix(varName, strings.ToUpper(prefix)) {
			f := string(varName[len(prefix):][0])
			if f == strings.ToLower(f) {
				ret = prefix
				break
			}
		}
	}
	return ret
}

func getVarValueName(mode, varName string) string {
	ret := ""
	provider := getDataProvider(mode)
	for _, p := range provider.Providers {
		prefix := p.GetName()
		if strings.HasPrefix(varName, strings.ToLower(prefix)) {
			f := string(varName[len(prefix):][0])
			if f == strings.ToUpper(f) {
				ret = varName[len(prefix):]
				break
			}
		} else if strings.HasPrefix(varName, strings.ToUpper(prefix)) {
			f := string(varName[len(prefix):][0])
			if f == strings.ToLower(f) {
				ret = varName[len(prefix):]
				break
			}
		}
	}
	return ret
}

func getPreferredMethod(annotations map[string]string) string {
	preferedMethod := "GET"
	if m, ok := annotations["metods"]; ok {
		methods := commaArgsToSlice(m)
		if len(methods) > 0 {
			preferedMethod = strings.ToUpper(methods[0])
		}
	}
	return preferedMethod
}

func mergeAnnotations(structAnnot, methodAnnot map[string]string) map[string]string {
	ret := map[string]string{}
	for k, v := range methodAnnot {
		ret[k] = v
	}
	for k, v := range structAnnot {
		if _, ok := ret[k]; !ok {
			ret[k] = v
		}
	}
	return ret
}

func makeCommentLines(s string) string {
	s = strings.TrimSpace(s)
	comment := ""
	for _, k := range strings.Split(s, "\n") {
		comment += "// " + k + "\n"
	}
	comment = strings.TrimSpace(comment)
	if comment == "" {
		comment = "//"
	}
	return comment
}

func commaArgsToSlice(s string) []string {
	ret := []string{}
	for _, l := range strings.Split(s, ",") {
		l = strings.TrimSpace(l)
		if l != "" {
			ret = append(ret, l)
		}
	}
	return ret
}

func getPkgToLoad() string {
	gopath := filepath.Join(os.Getenv("GOPATH"), "src")
	pkgToLoad, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	return pkgToLoad[len(gopath)+1:]
}
